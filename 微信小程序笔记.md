# 1 小程序框架
响应的数据绑定   
```html
<!-- This is our View -->
<view> Hello {{name}}! </view>
<button bindtap="changeName"> Click me! </button>
```
```javascript
// This is our App Service.
// This is our data.
var helloData = {
  name: 'WeChat'
}

// Register a Page.
Page({
  data: helloData,	// 注意：App的配置对象里面没有data，但可以随意添加属性
  changeName: function(e) {
    // sent data change to view
	// 使用setData方法来修改页面的data属性的值
    this.setData({
      name: 'MINA'
    })
  }
})
```

## 1.1 场景值
场景值用来描述用户进入小程序的途径(如从小程序中打开，公众号自定义菜单等)   

### 1.1.1 获取场景值
> 1、在`App`的`onLaunch`和`onShow`的传入参数中获取`scene`的值   
> 2、其他地方，可以用`wx.getLaunchOptionsSync`获取传入`onLaunch`和`onShow`的对象，再获取`scene`的值   
> 3、对于小游戏，可以用`wx.getLaunchOptionsSync`或`wx.onShow`中获取场景值   


## 1.2 逻辑层 App Service
小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。   
开发者写的所有代码会被打包成一个js文件，在小程序启动的时候运行，直至小程序销毁。   

### 1.2.1 在js的基础之上增加的功能
* `App()`和`Page()`方法，用来进行`程序注册`和`页面注册`
* `getApp()`和`getCurrentPages()`，用来获取App实例和当前页面栈
* 提供丰富的API，如微信用户数据、扫一扫、支付等微信特有的能力
* 提供模块化能力，每个页面都有独立的作用域
* **注意：小程序框架的逻辑层不是运行在浏览器中的，所以js在web中的一些功能没有了，例如`window`和`document`等**

### 1.2.2 注册小程序
* 调用App()来注册小程序。接收一个对象作为参数来指定小程序的生命周期回调等。
* App()只能在app.js中调用，并且只能调用一次。
* **一个小程序只有一个App实例**

App(obj)里 obj配置 预设的生命周期回调函数   
* `onLaunch(Objecct obj)`	监听小程序初始化，参数也可以使用 wx.getLaunchOptionsSync 获取。
* `onShow(Objecct obj)`	监听小程序启动或切前台，参数也可以使用 wx.getLaunchOptionsSync 获取。也可以使用wx.onAppShow绑定监听
* `onHide()`	监听小程序切后台，也可以使用wx.onAppHide绑定监听
* `onError(String err)`	错误监听函数，也可以使用wx.onError绑定监听
* `onPageNotFound(Objecct obj)`	页面不存在监听函数，也可以使用wx.onPageNotFound绑定监听。

配置示例
```javascript
// 调用App()方法注册小程序
App({
  onLaunch(options) {
    // 小程序启动的时候调用，整个小程序只启动一次
  },

  onShow(options) {
    // 监听小程序启动或切前台
  },

  onHide() {
    // 监听小程序切后台
  },

  onError(err) {
    // 错误监听函数
  },

  onPageNotFound() {
    // 页面不存在监听函数
  }
});
```

全局方法getApp()   
获取App实例，一般用来获取自己定义的全局数据
```javascript
var appInstance = getApp()
console.log(appInstance.globalData)
```

### 1.2.3 注册页面
注册一个页面，指定页面初始数据、生命周期回调、事件处理函数等

obj中部分已定义的参数
* data	页面的初始数据
* onLoad	监听页面加载
* onShow	监听页面显示
* onReady	监听页面初次渲染完成
* onPullDownRefresh	监听用户下拉操作

### 1.2.4 页面路由
> 小程序中所有页面的路由由框架进行管理

页面栈
> 框架以栈的形式来维护所有页面

路由方式（以下调用API的方式都可以使用navigator组件来完成相同的效果）
* 初始化
* 打开新页面	`wx.navigateTo`
* 页面重定向	`wx.redirectTo`
* 页面返回	`wx.navigateBack`
* Tab切换	`wx.switchTab`
* 重启动		`wx.reLaunch`

注意事项
* `wx.navigateTo` 和 `wx.redirectTo` 只能打开非tabBar页面
* `switchTab` 只能打开tabBar页面
* `reLaunch` 可以打开tabBar页面和非tabBar页面

### 1.2.5 模块化
可以将一些公共的js代码抽离成一个js文件，作为一个模块，通过`module.exports`和`require`来导出导入模块

**注意**
* 小程序不支持直接引入node_modules

**文件作用域**    
> 在js文件中声明的函数和变量只在该文件内有效，其他文件也可以声明相同名字的变量。   
> 如果需要全局的数据，可以在App()中的配置对象里定义，并在其他页面中通过`getApp().yourData`来获取数据

### 1.2.6 API
小程序框架提供丰富的微信原生API，可以方便地调用微信提供的能力，如微信支付、本地储存等。

API的种类
* 事件监听API
* 同步API
* 异步API

事件监听API
> 以on开头的API用来监听某个事件是否被触发，如`wx.onSocketOpen`

同步API
> 以Sync结尾的都是同步API，如`wx.setStorageSync`。此外，也有一些其他的同步API，例如`wx.createWorker`

异步API
> 大多数API都是异步API，如`wx.request`、`wx.login`等。这类API通常都接受一个对象作为参数，里面指定对应的回调函数，如成功、失败回调函数等。


## 1.3 视图层View
> 框架的视图层由WXML和WXSS进行编写，由组件来进行展示。   
> 将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。   
> WXML(WeiXin Markup language) 用于描述页面的结构。   
> WXS(WeiXin Script) 是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。   
> WXSS(WeiXin Style Sheet) 用于描述页面的样式。   
> 组件(Component)是视图的基本组成单元。   

### 1.3.1 WXML
> WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合`基础组件`、`事件系统`，可以构建出页面的结构。

#### 1.3.1.1 数据绑定
与Vue一样，使用`{{  }}`进行数据绑定，绑定的是`Page`上的`data`选项   
与Vue的不同之处是，没有了v-bind这一种绑定，都是直接用{{  }}绑定即可   
```html
<view id="item-{{id}}"> </view>
```
```javascript
Page({
	data: {
		id: 0
	}
})
```

#### 1.3.1.2 列表渲染
使用wx:for进行列表渲染
```html
<view wx:for="{{array}}">
  {{index}}: {{item.message}}
</view>
```
```javascript
Page({
  data: {
    array: [{
      message: 'foo',
    }, {
      message: 'bar'
    }]
  }
})
```

wx:for可以嵌套
```html
<!-- 九九乘法表 -->
<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">
  <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">
    <view wx:if="{{i <= j}}">
      {{i}} * {{j}} = {{i * j}}
    </view>
  </view>
</view>
```

如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用`wx:key`来指定列表中项目的唯一的标识符。   
与Vue不一样的是，wx:key的值只能取两种值：
- 字符串，代表在for循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。   
- 保留关键字`*this`代表在for循环中的`item`本身，这种表示需要`item`本身是一个唯一的字符串或者数字   

```html
<!-- 会将unique解析成item.unique -->
<switch wx:for="{{objectArray}}" wx:key="unique" style="display: block;"> {{item.id}} </switch>

<!-- *this代表item自身 -->
<switch wx:for="{{numberArray}}" wx:key="*this" style="display: block;"> {{item}} </switch>
```

当wx:for的值为字符串时，会解析成字符串数组，例如：
```html
<view wx:for="array">
  {{item}}
</view>
```
等同于：
```html
<view wx:for="{{['a','r','r','a','y']}}">
  {{item}}
</view>
```

#### 1.3.1.3 条件渲染
与Vue类似，`wx-if`对应v-if，`wx-else`对应v-else，`wx-elif`对应v-else-if
```html
<view wx:if="{{true}}"> True </view>
```
如果涉及到多个标签的话，可以用`block`标签（相当于Vue中的`template`）将它们包起来，在`block`上使用`wx:if`
```html
<block wx:if="{{ true }}">
	<view>1</view>
	<view>2</view>
</block>
```
**注意：`<block/>`并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。**   
**`hidden`属性与`wx:if`对应Vue中的`v-show`和`v-if`**


### WXSS
在css的基础上主要扩充了尺寸单位和样式导入
* 新的长度单位：`rpx`，规定屏幕的宽度为750rpx
* 使用`@import "路径";`可以在WXSS文件中导入外部的样式
* 框架的组件支持用class和style属性控制内联样式

### WXS(WeiXin Script)
wxs是微信的一套脚本语言，与js是不同的语言，不能使用其他js文件中定义的函数，也不能调用小程序的API。
wxs与wxml配合使用，不过还是和js很像
用wxs来响应事件的话，可以提升性能

### 事件系统
事件是视图层到逻辑层的通讯方式

#### WXML有自己的事件，绑定方式有两种: `bind` 和 `catch`，如`bindtap`
* catch可以阻止事件冒泡
* 事件有捕获和冒泡阶段，先捕获再冒泡
* 想要绑定在捕获阶段的事件的话，可以采用`capture-bind`或`capture-catch`来绑定事件，其中`capture-catch`会把之后的捕获和冒泡过程全部中止。
* 与js一样，事件的回调函数会传入一个event对象，不过里面的属性有些不同
* 组件可以增加自定义属性，形如`data-name`，如果有多个单词，就继续用`-`连接，在用js获取的时候会转成驼峰。

#### 事件对象里面的一些属性
* mark	与自定义属性dataset类似，不过mark会包含从触发节点到根节点上的所有mark，而data只有currentTarget上的属性
* mark不会做大小写转换，dataset会

## 小程序没有类似`v-bind`的写法
与Vue的数据绑定有点不一样，小程序的wxml页面在节点属性的值处可以写`{{}}`插值表达式，不使用类似`v-bind`的写法
```html
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```

## slot节点
与Vue类似，子组件中可以定义`slot`节点来接受父组件的内容

### 使用多个slot
要使用多个slot，需要在组件配置文件中声明使用多个slot
```javascript
Component({
  options: {
    multipleSlots: true // 在组件定义时的选项中启用多slot支持
  },
  properties: { /* ... */ },
  methods: { /* ... */ }
})
```
声明了之后，就可以在组件中使用多个slot节点，以name属性来区分
```html
<!-- 组件模板 -->
<view class="wrapper">
  <slot name="before"></slot>
  <view>这里是组件的内部细节</view>
  <slot name="after"></slot>
</view>
```
接下来就可以在父组件中使用这些slot，需要定义slot属性来指定对应的slot名字
```html
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
    <view slot="before">这里是插入到组件slot name="before"中的内容</view>
    <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
    <view slot="after">这里是插入到组件slot name="after"中的内容</view>
  </component-tag-name>
</view>
```

## 组件的样式选择器尽量使用class选择器，其他的可能会有问题

## 组件间通信

### 父组件向子组件传值，与Vue类似，利用属性传值，不同的地方是：子组件中声明的是`properties`对象

### 子组件向父组件传值，与Vue类似，利用自定义事件，子组件触发自定义事件使用`this.triggerEvent(事件名, detail对象, 事件选项)`